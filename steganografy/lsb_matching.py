import numpy as np
from PIL import Image
import random
from steganografy.steganography import Steganography

class LsbMatching(Steganography):
    """
    Generated by Gemini AI

    Implements LSB Matching Steganography (also known as ±1 Embedding).

    When a modification is required, the pixel value is randomly incremented 
    or decremented by 1 to maintain the statistical histogram and resist steganalysis.
    """

    def __init__(self):
        """Initializes the LsbMatching class."""
        self.header_len_bits = 32  # 32 bits to store the message length in bytes

    def _message_to_binary(self, message):
        """Converts a string message into a binary string, prefixed by its length."""
        # Encode message to bytes and get length
        message_bytes = message.encode('utf-8')
        message_length = len(message_bytes)
        
        # Format length into 32 bits (4 bytes)
        length_binary = format(message_length, f'0{self.header_len_bits}b')
        
        # Convert message bytes to binary string
        data_binary = ''.join([format(byte, '08b') for byte in message_bytes])
        
        return length_binary + data_binary

    def _binary_to_message(self, binary_data):
        """Converts a binary string back into a human-readable string."""
        if not binary_data:
            return ""
            
        # Convert the binary string to bytes
        byte_list = []
        for i in range(0, len(binary_data), 8):
            byte_str = binary_data[i:i+8]
            byte_list.append(int(byte_str, 2))
        
        return bytes(byte_list).decode('utf-8')


    def encode_message(self, image_path, message, output_path="stego_matching.png"):
        """
        Hides a message in the cover image using LSB Matching.

        :param image_path: Path to the cover image.
        :param message: The secret message string to hide.
        :param output_path: Path to save the resulting stego image.
        :return: True if successful, False otherwise.
        """
        try:
            # 1. Image and Data Preparation
            img = Image.open(image_path).convert('RGB')
            img_array = np.array(img, dtype=np.uint8)
            
            flat_array = img_array.flatten()
            total_channels = len(flat_array)

            binary_message = self._message_to_binary(message)
            message_len = len(binary_message)
            
            # 2. Capacity Check
            if message_len > total_channels:
                print(f"ERROR: Message ({message_len} bits) is too large.")
                print(f"Available capacity (channels): {total_channels} bits.")
                return False

            print(f"Embedding {message_len} bits using LSB Matching (±1 logic)...")

            # 3. LSB Matching Embedding
            for i in range(message_len):
                
                channel_index = i # Sequential embedding for simplicity here, but can be randomized too
                secret_bit = int(binary_message[i])
                
                channel_val = flat_array[channel_index]
                current_lsb = channel_val & 1 # 0 or 1

                if secret_bit != current_lsb:
                    # Modification is necessary. We must change the LSB.
                    
                    # Randomly choose +1 or -1 modification
                    # Note: We must ensure the pixel value stays within the 0-255 range.
                    # This check is simplified here as most changes won't hit boundaries.
                    modification = random.choice([-1, 1])
                    
                    # Apply the modification
                    new_channel_val = channel_val + modification
                    
                    # Small Boundary Check (prevents wrap-around if possible, though LSB Matching
                    # usually accepts the boundary change for better statistical properties)
                    if new_channel_val > 255:
                        # If incrementing overflows, we must use -1.
                        new_channel_val = channel_val - 1
                    elif new_channel_val < 0:
                        # If decrementing underflows, we must use +1.
                        new_channel_val = channel_val + 1
                    
                    # After modification, the LSB MUST match the secret bit
                    # if (new_channel_val & 1) != secret_bit:
                    #     raise Exception("LSB Matching logic error.") 

                    flat_array[channel_index] = new_channel_val
                
                # If secret_bit == current_lsb, no modification is needed (P' = P),
                # so we do nothing, preserving the original pixel value.
            
            # 4. Save Stego-Image
            stego_array = flat_array.reshape(img_array.shape)
            stego_img = Image.fromarray(stego_array, 'RGB')
            stego_img.save(output_path)
            
            print(f"Message successfully encoded and saved to {output_path}")
            return True

        except FileNotFoundError:
            print(f"ERROR: Image file not found at {image_path}")
            return False
        except Exception as e:
            print(f"An error occurred during encoding: {e}")
            return False


    def decode_message(self, stego_image_path):
        """
        Extracts a message hidden in the stego image by sequentially reading the LSB.
        
        The extraction process is identical to standard LSB, as the matching logic 
        is only needed during embedding.

        :param stego_image_path: Path to the stego image.
        :return: The extracted message string or None if unsuccessful.
        """
        try:
            # 1. Image Preparation
            stego_img = Image.open(stego_image_path).convert('RGB')
            stego_array = np.array(stego_img, dtype=np.uint8)
            flat_array = stego_array.flatten()
            
            # 2. Extract Header (Message Length)
            
            # Read the first self.header_len_bits LSBs sequentially
            length_bits = []
            for i in range(self.header_len_bits):
                channel_val = flat_array[i]
                lsb = channel_val & 1
                length_bits.append(str(lsb))
            
            # Convert binary length to integer
            binary_length = "".join(length_bits)
            message_byte_length = int(binary_length, 2)
            total_message_bits_needed = message_byte_length * 8
            
            print(f"Extracted message length header: {message_byte_length} bytes ({total_message_bits_needed} bits)")
            
            # 3. Message Data Extraction
            
            # Read the subsequent bits (starting after the header)
            message_bits = []
            start_index = self.header_len_bits
            end_index = start_index + total_message_bits_needed
            
            if end_index > len(flat_array):
                print("ERROR: Message extends beyond image capacity.")
                return None
            
            for i in range(start_index, end_index):
                channel_val = flat_array[i]
                # Extract the LSB
                lsb = channel_val & 1
                message_bits.append(str(lsb))
            
            # 4. Conversion and Result
            extracted_binary_data = "".join(message_bits)
            extracted_message = self._binary_to_message(extracted_binary_data)
            
            return extracted_message

        except FileNotFoundError:
            print(f"ERROR: Stego image file not found at {stego_image_path}")
            return None
        except Exception as e:
            print(f"An error occurred during decoding: {e}")
            return None


# --- Example Usage ---

if __name__ == '__main__':
    # NOTE: You will need a sample image (e.g., 'cover.png') and the Pillow/numpy 
    # installed ('pip install Pillow numpy') to run this section.
    
    # 1. Setup
    stego = LsbMatching()
    
    # Create a dummy image if one doesn't exist for a runnable example
    dummy_path = "dummy_cover_matching.png"
    try:
        # Create a simple uniform image
        base_array = np.full((100, 100, 3), 128, dtype=np.uint8) 
        dummy_img = Image.fromarray(base_array, 'RGB')
        dummy_img.save(dummy_path)
        print(f"Created uniform dummy cover image at: {dummy_path}")
    except Exception as e:
        print(f"Could not create dummy image (required PIL/numpy): {e}")

    cover_image_file = dummy_path
    secret_message = "LSB Matching reduces statistical artifacts by randomly choosing between plus one and minus one when a change is needed."
    output_image_file = "stego_matching_output.png"
    
    # 2. Encoding
    print("\n--- Starting LSB Matching Encoding ---")
    success = stego.encode_message(cover_image_file, secret_message, output_image_file)

    if success:
        # 3. Decoding
        print("\n--- Starting Decoding ---")
        extracted_message = stego.decode_message(output_image_file)
        
        if extracted_message is not None:
            print("\nVerification:")
            print(f"Original Message: '{secret_message}'")
            print(f"Extracted Message: '{extracted_message}'")

            if secret_message == extracted_message:
                print("\nSUCCESS: Original and extracted messages match!")
            else:
                print("\nFAILURE: Messages do not match.")
