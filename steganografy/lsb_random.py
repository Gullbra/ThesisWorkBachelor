import numpy as np
from PIL import Image
import random
from steganografy.steganography import Steganography

class LsbRandom(Steganography):
    """
    Generated by Gemini AI

    Implements Randomized LSB Steganography.

    Data is embedded into pixel locations determined by a Pseudo-Random 
    Number Generator (PRNG) that is seeded by a secret key. This secures 
    the location of the data.
    """

    def __init__(self, key):
        """
        Initializes the LsbRandom class.
        :param key: The secret integer key/seed used for the PRNG path generation.
        """
        if not isinstance(key, int):
            raise ValueError("Key must be an integer (PRNG seed).")
            
        self.key = key
        self.header_len_bits = 32  # 32 bits to store the message length in bytes

    def _message_to_binary(self, message):
        """Converts a string message into a binary string, prefixed by its length."""
        # Encode message to bytes and get length
        message_bytes = message.encode('utf-8')
        message_length = len(message_bytes)
        
        # Format length into 32 bits (4 bytes)
        length_binary = format(message_length, f'0{self.header_len_bits}b')
        
        # Convert message bytes to binary string
        data_binary = ''.join([format(byte, '08b') for byte in message_bytes])
        
        # Total binary data includes the 32-bit length header
        return length_binary + data_binary

    def _binary_to_message(self, binary_data):
        """Converts a binary string back into a human-readable string."""
        if not binary_data:
            return ""
            
        # Convert the binary string to bytes
        byte_list = []
        for i in range(0, len(binary_data), 8):
            byte_str = binary_data[i:i+8]
            byte_list.append(int(byte_str, 2))
        
        # Decode the bytes back to a UTF-8 string
        return bytes(byte_list).decode('utf-8')

    def _get_shuffled_indices(self, total_pixels):
        """
        Generates a reproducible, shuffled list of indices based on the secret key.
        This defines the secret embedding path.
        """
        # Initialize the PRNG with the secret key
        prng = random.Random(self.key)
        
        # Create a list of all available indices (0 up to total_pixels - 1)
        indices = list(range(total_pixels))
        
        # Shuffle the list using the seeded PRNG
        prng.shuffle(indices)
        
        return indices


    def encode_message(self, image_path, message, output_path="stego_random.png"):
        """
        Hides a message in the cover image using Randomized LSB Replacement.

        :param image_path: Path to the cover image.
        :param message: The secret message string to hide.
        :param output_path: Path to save the resulting stego image.
        :return: True if successful, False otherwise.
        """
        try:
            # 1. Image and Data Preparation
            img = Image.open(image_path).convert('RGB')
            img_array = np.array(img, dtype=np.uint8)
            
            # Flatten the array to get a 1D list of all R, G, B channel values
            flat_array = img_array.flatten()
            total_channels = len(flat_array)

            binary_message = self._message_to_binary(message)
            message_len = len(binary_message)
            
            # 2. Capacity Check
            if message_len > total_channels:
                print(f"ERROR: Message ({message_len} bits) is too large.")
                print(f"Available total capacity (channels): {total_channels} bits.")
                return False

            # 3. Path Generation
            print(f"Generating random embedding path using key: {self.key}...")
            shuffled_indices = self._get_shuffled_indices(total_channels)
            
            # The indices we use are the first 'message_len' elements of the shuffled list
            embedding_path = shuffled_indices[:message_len]

            # 4. LSB Embedding
            print(f"Embedding {message_len} bits into randomized pixel channels...")
            
            for i, channel_index in enumerate(embedding_path):
                # Get the secret bit (0 or 1)
                secret_bit = int(binary_message[i])
                
                # Get the current channel value
                channel_val = flat_array[channel_index]
                
                # Use bitwise operation to replace the LSB
                # 1. Clear the current LSB (AND with ...11111110)
                # 2. Set the new LSB (OR with the secret bit)
                new_channel_val = (channel_val & 0b11111110) | secret_bit
                
                # Update the array
                flat_array[channel_index] = new_channel_val
            
            # 5. Save Stego-Image
            stego_array = flat_array.reshape(img_array.shape)
            stego_img = Image.fromarray(stego_array, 'RGB')
            stego_img.save(output_path)
            
            print(f"Message successfully encoded and saved to {output_path}")
            return True

        except FileNotFoundError:
            print(f"ERROR: Image file not found at {image_path}")
            return False
        except Exception as e:
            print(f"An error occurred during encoding: {e}")
            return False


    def decode_message(self, stego_image_path):
        """
        Extracts a message hidden in the stego image using the stored key.
        
        :param stego_image_path: Path to the stego image.
        :return: The extracted message string or None if unsuccessful.
        """
        try:
            # 1. Image Preparation
            stego_img = Image.open(stego_image_path).convert('RGB')
            stego_array = np.array(stego_img, dtype=np.uint8)
            flat_array = stego_array.flatten()
            total_channels = len(flat_array)
            
            # 2. Path Generation (Crucial: Must use the same key!)
            print(f"Re-generating random path using key: {self.key}...")
            shuffled_indices = self._get_shuffled_indices(total_channels)

            # 3. Extract Header (Message Length)
            
            # The header is stored in the first `self.header_len_bits` indices of the shuffled path
            header_path = shuffled_indices[:self.header_len_bits]
            length_bits = []
            
            for index in header_path:
                channel_val = flat_array[index]
                # Extract the LSB (AND with 1)
                lsb = channel_val & 1
                length_bits.append(str(lsb))
            
            if len(length_bits) < self.header_len_bits:
                print("ERROR: Could not extract full message length header.")
                return None
                
            # Convert binary length to integer
            binary_length = "".join(length_bits)
            message_byte_length = int(binary_length, 2)
            total_message_bits_needed = message_byte_length * 8
            
            # 4. Message Data Extraction
            
            # The message starts immediately after the header in the shuffled path
            data_path = shuffled_indices[self.header_len_bits : self.header_len_bits + total_message_bits_needed]
            message_bits = []
            
            for index in data_path:
                channel_val = flat_array[index]
                # Extract the LSB (AND with 1)
                lsb = channel_val & 1
                message_bits.append(str(lsb))
            
            if len(message_bits) < total_message_bits_needed:
                print("ERROR: Incomplete message extraction. The hidden data path ended prematurely.")
                return None

            # 5. Conversion and Result
            extracted_binary_data = "".join(message_bits)
            extracted_message = self._binary_to_message(extracted_binary_data)
            
            print(f"Extracted {message_byte_length} bytes from the randomized path.")
            return extracted_message

        except FileNotFoundError:
            print(f"ERROR: Stego image file not found at {stego_image_path}")
            return None
        except Exception as e:
            print(f"An error occurred during decoding: {e}")
            return None


# --- Example Usage ---

if __name__ == '__main__':
    # NOTE: You will need a sample image (e.g., 'cover.png') and the Pillow/numpy 
    # installed ('pip install Pillow numpy') to run this section.
    
    # --- Setup ---
    SECRET_KEY = 123456789 # This key MUST be shared and used for both encoding/decoding
    stego = LsbRandom(key=SECRET_KEY)
    
    # Create a dummy image if one doesn't exist for a runnable example
    dummy_path = "dummy_cover_random.png"
    try:
        # Create a simple uniform image
        base_array = np.full((100, 100, 3), 128, dtype=np.uint8) 
        dummy_img = Image.fromarray(base_array, 'RGB')
        dummy_img.save(dummy_path)
        print(f"Created uniform dummy cover image at: {dummy_path}")
    except Exception as e:
        print(f"Could not create dummy image (required PIL/numpy): {e}")

    cover_image_file = dummy_path
    secret_message = "Randomization makes steganalysis difficult without the key!"
    output_image_file = "stego_random_output.png"
    
    # 2. Encoding
    print("\n--- Starting Randomized Encoding ---")
    success = stego.encode_message(cover_image_file, secret_message, output_image_file)

    if success:
        # 3. Decoding (Using the correct key)
        print("\n--- Starting Decoding (Correct Key) ---")
        extracted_message = LsbRandom(key=SECRET_KEY).decode_message(output_image_file)
        
        if extracted_message is not None:
            print("\nVerification:")
            print(f"Original Message: '{secret_message}'")
            print(f"Extracted Message: '{extracted_message}'")

            if secret_message == extracted_message:
                print("\nSUCCESS: Original and extracted messages match!")
            else:
                print("\nFAILURE: Messages do not match.")
        
        # 4. Decoding Attempt (Using the wrong key)
        print("\n--- Starting Decoding Attempt (Wrong Key) ---")
        wrong_message = LsbRandom(key=99999).decode_message(output_image_file)
        
        if wrong_message is not None and wrong_message == secret_message:
             print("\nFAILURE: Wrong key somehow worked!")
        else:
            print(f"\nExpected Garbage: The message extracted with the wrong key is: '{wrong_message[:20]}...' (or similar garbage)")
            print("SUCCESS: The randomization worked! Wrong key failed to extract the original message.")