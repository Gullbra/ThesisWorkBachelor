import numpy as np
from PIL import Image
from steganography.steganography import Steganography

class LsbEdge(Steganography):
    """
    Generated by Gemini AI

    Implements Edge Detection Based Adaptive LSB Steganography.

    Data is embedded only in 'complex' regions (edges/textures) of the image, 
    as determined by a simple Sobel-like gradient approximation. This improves
    the visual fidelity and security against simple statistical attacks compared 
    to sequential or randomized LSB replacement.
    """

    def __init__(self, threshold=30):
        """
        Initializes the LsbEdge class.
        :param threshold: The minimum gradient magnitude (complexity) a pixel must
                          have to be considered an 'edge' for embedding. Default is 30.
        """
        self.threshold = threshold
        self.header_len_bits = 32  # Use 32 bits to store the message length

    def _message_to_binary(self, message):
        """Converts a string message into a binary string."""
        # Prepend the length of the message in bytes as a 32-bit binary string
        message_bytes = message.encode('utf-8')
        message_length = len(message_bytes)
        
        # Format length into 32 bits
        length_binary = format(message_length, f'0{self.header_len_bits}b')
        
        # Convert message bytes to binary string
        data_binary = ''.join([format(byte, '08b') for byte in message_bytes])
        
        return length_binary + data_binary

    def _binary_to_message(self, binary_data):
        """Converts a binary string back into a human-readable string."""
        if not binary_data:
            return ""
            
        # Convert the binary string to bytes
        byte_list = []
        for i in range(0, len(binary_data), 8):
            byte_str = binary_data[i:i+8]
            byte_list.append(int(byte_str, 2))
        
        # Decode the bytes back to a UTF-8 string
        return bytes(byte_list).decode('utf-8')

    def _get_edge_mask(self, img_array):
        """
        Generates a boolean mask identifying 'edge' pixels based on gradient magnitude.
        
        This uses a simple approximation of the Sobel filter (calculating the 
        difference with neighboring pixels) on the red channel for speed.
        """
        # Convert to grayscale/single channel array for edge detection simplicity
        # We use the Red channel (index 0) for the complexity calculation.
        R = img_array[:, :, 0].astype(np.int16) 
        
        # Calculate horizontal and vertical gradients (Sobel approximation)
        # Gx: Difference with the pixel to the left (shift column right by 1)
        Gx = np.zeros_like(R)
        Gx[:, 1:-1] = R[:, 2:] - R[:, :-2]
        
        # Gy: Difference with the pixel above/below (shift row down by 1)
        Gy = np.zeros_like(R)
        Gy[1:-1, :] = R[2:, :] - R[:-2, :]

        # Calculate the gradient magnitude (approximation: sum of absolute differences)
        gradient_magnitude = np.abs(Gx) + np.abs(Gy)

        # Create the edge mask: True where magnitude exceeds the threshold
        edge_mask = gradient_magnitude >= self.threshold
        
        return edge_mask

    def encode_message(self, image_path, message, output_path="stego_image.png"):
        """
        Hides a message in the cover image using Edge Adaptive LSB Replacement.

        :param image_path: Path to the cover image (e.g., 'cover.png').
        :param message: The secret message string to hide.
        :param output_path: Path to save the resulting stego image.
        :return: True if successful, False otherwise.
        """
        try:
            # 1. Image and Data Preparation
            img = Image.open(image_path).convert('RGB')
            img_array = np.array(img, dtype=np.uint8)
            height, width, depth = img_array.shape
            
            binary_message = self._message_to_binary(message)
            message_len = len(binary_message)
            current_bit = 0

            # 2. Edge Detection and Capacity Check
            print("Analyzing image complexity to find optimal embedding regions...")
            edge_mask = self._get_edge_mask(img_array)
            
            # The mask is 2D (H x W). We need to check capacity in terms of all 3 color channels.
            available_capacity = np.sum(edge_mask) * 3
            
            if message_len > available_capacity:
                print(f"ERROR: Message ({message_len} bits) is too large.")
                print(f"Available edge capacity: {available_capacity} bits.")
                return False

            print(f"Embedding {message_len} bits into {np.sum(edge_mask)} edge pixels...")

            # 3. LSB Embedding
            # Flatten the array for easier iteration
            flat_array = img_array.flatten()
            
            # Create a 1D version of the 3-channel edge mask
            # For every pixel (i, j), we check if edge_mask[i, j] is True. If so, 
            # all three color channels (R, G, B) at that location are candidates.
            edge_indices = np.where(edge_mask)
            
            # Iterate through the (row, col) indices of the detected edge pixels
            for r, c in zip(*edge_indices):
                
                # Iterate through R, G, B channels at this edge pixel (indices 0, 1, 2)
                for channel in range(depth):
                    
                    if current_bit < message_len:
                        # Calculate the 1D index for the current color channel
                        # Index = (row * width * depth) + (col * depth) + channel
                        idx = (r * width * depth) + (c * depth) + channel
                        
                        # Get the secret bit (0 or 1)
                        secret_bit = int(binary_message[current_bit])
                        
                        # Get the current pixel value
                        pixel_val = flat_array[idx]
                        
                        # Use bitwise operation to replace the LSB
                        # 1. Clear the current LSB (AND with ...11111110)
                        # 2. Set the new LSB (OR with the secret bit)
                        new_pixel_val = (pixel_val & 0b11111110) | secret_bit
                        
                        # Update the array
                        flat_array[idx] = new_pixel_val
                        current_bit += 1
                    else:
                        # Message is fully embedded
                        break
                
                if current_bit >= message_len:
                    break
            
            # 4. Save Stego-Image
            stego_array = flat_array.reshape(height, width, depth)
            stego_img = Image.fromarray(stego_array, 'RGB')
            stego_img.save(output_path)
            
            print(f"Message successfully encoded and saved to {output_path}")
            return True

        except FileNotFoundError:
            print(f"ERROR: Image file not found at {image_path}")
            return False
        except Exception as e:
            print(f"An error occurred during encoding: {e}")
            return False


    def decode_message(self, stego_image_path):
        """
        Extracts a message hidden in the stego image using the same Edge Adaptive method.
        
        :param stego_image_path: Path to the stego image (e.g., 'stego_image.png').
        :return: The extracted message string or None if unsuccessful.
        """
        try:
            # 1. Image Preparation
            stego_img = Image.open(stego_image_path).convert('RGB')
            stego_array = np.array(stego_img, dtype=np.uint8)
            height, width, depth = stego_array.shape
            
            # 2. Re-detect Edges
            print("Re-analyzing image complexity to find embedded regions...")
            edge_mask = self._get_edge_mask(stego_array)
            
            # 3. Message Length Extraction
            length_bits = []
            flat_array = stego_array.flatten()
            edge_indices = np.where(edge_mask)
            
            # Iterate through all color channels of the edge pixels until we find the length
            extraction_count = 0
            
            for r, c in zip(*edge_indices):
                for channel in range(depth):
                    if extraction_count < self.header_len_bits:
                        
                        idx = (r * width * depth) + (c * depth) + channel
                        pixel_val = flat_array[idx]
                        
                        # Extract the LSB (AND with 1)
                        lsb = pixel_val & 1
                        length_bits.append(str(lsb))
                        
                        extraction_count += 1
                    else:
                        break
                
                if extraction_count >= self.header_len_bits:
                    break

            if len(length_bits) < self.header_len_bits:
                print("ERROR: Could not extract full message length header. Hidden data may be missing or the key/threshold is incorrect.")
                return None
                
            # Convert binary length to integer
            binary_length = "".join(length_bits)
            message_byte_length = int(binary_length, 2)
            
            # Total bits needed: (message_byte_length * 8)
            total_message_bits_needed = message_byte_length * 8
            
            print(f"Extracted message length: {message_byte_length} bytes ({total_message_bits_needed} bits)")
            
            # 4. Message Data Extraction
            message_bits = []
            
            # Continue iterating from where the length header stopped
            current_bit = self.header_len_bits
            
            # Restart the loop to ensure clean indexing, but skip the already-read header bits
            bit_counter = 0 # tracks which bit *should* be read (0 to total_message_bits_needed - 1)
            
            for r, c in zip(*edge_indices):
                for channel in range(depth):
                    
                    if bit_counter < total_message_bits_needed:
                        
                        # Skip the bits already used for the header
                        if current_bit > 0:
                            current_bit -= 1
                            continue 
                        
                        idx = (r * width * depth) + (c * depth) + channel
                        pixel_val = flat_array[idx]
                        
                        # Extract the LSB (AND with 1)
                        lsb = pixel_val & 1
                        message_bits.append(str(lsb))
                        
                        bit_counter += 1
                    else:
                        break
                
                if bit_counter >= total_message_bits_needed:
                    break
            
            if len(message_bits) < total_message_bits_needed:
                print("ERROR: Incomplete message extraction. The data in the image ended prematurely.")
                return None

            # 5. Conversion and Result
            extracted_binary_data = "".join(message_bits)
            extracted_message = self._binary_to_message(extracted_binary_data)
            
            return extracted_message

        except FileNotFoundError:
            print(f"ERROR: Stego image file not found at {stego_image_path}")
            return None
        except Exception as e:
            print(f"An error occurred during decoding: {e}")
            return None


# --- Example Usage ---

if __name__ == '__main__':
    # NOTE: You will need a sample image (e.g., 'cover.png') and the Pillow/numpy libraries 
    # installed ('pip install Pillow numpy') to run this section.
    
    # 1. Setup
    stego = LsbEdge(threshold=35) # Adjust threshold for sensitivity
    
    # Create a dummy image if one doesn't exist for a runnable example
    dummy_path = "dummy_cover.png"
    try:
        # Create a simple image with some 'edges' (a sharp transition)
        base_array = np.zeros((100, 100, 3), dtype=np.uint8)
        base_array[:, :50] = [255, 0, 0]    # Red half
        base_array[:, 50:] = [0, 255, 0]     # Green half
        dummy_img = Image.fromarray(base_array, 'RGB')
        dummy_img.save(dummy_path)
        print(f"Created dummy cover image at: {dummy_path}")
    except Exception as e:
        print(f"Could not create dummy image (required PIL/numpy): {e}")

    cover_image_file = dummy_path
    secret_message = "This is my highly secret message embedded using adaptive LSB steganography!"
    output_image_file = "stego_output.png"
    
    # 2. Encoding
    print("\n--- Starting Encoding ---")
    success = stego.encode_message(cover_image_file, secret_message, output_image_file)

    if success:
        # 3. Decoding
        print("\n--- Starting Decoding ---")
        extracted_message = stego.decode_message(output_image_file)
        
        if extracted_message is not None:
            print("\nVerification:")
            print(f"Original Message: '{secret_message}'")
            print(f"Extracted Message: '{extracted_message}'")

            if secret_message == extracted_message:
                print("\nSUCCESS: Original and extracted messages match!")
            else:
                print("\nFAILURE: Messages do not match.")
